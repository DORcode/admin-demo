5.【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字
长。

6.【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类
命名以它要测试的类的名称开始，以 Test 结尾。

8.【强制】POJO 类中布尔类型变量都不要加 is 前缀，否则部分框架解析会引起序列化错误。
说明：在本文 MySQL 规约中的建表约定第一条，表达是与否的值采用 is_xxx 的命名方式，所以，需要在
<resultMap>设置从 is_xxx 到 xxx 的映射关系。
反例：定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()，RPC 框架在反向解
析的时候，“误以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。

9.【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使
用单数形式，但是类名如果有复数含义，类名可以使用复数形式。
正例：应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils（此规则参考 spring 的框架结构）

11.【强制】杜绝完全不规范的缩写，避免望文不知义。
反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重
降低了代码的可阅读性。

13.【推荐】在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。
正例：startTime / workQueue / nameList / TERMINATED_THREAD_COUNT
反例：startedAt / QueueOfWork / listName / COUNT_TERMINATED_THREAD

14.【推荐】如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。
说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。
Java 开发手册
 3/44
正例： public class OrderFactory;
 public class LoginProxy;
 public class ResourceObserver;
 
17.【参考】枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。
说明：枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有。
正例：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON。

18.【参考】各层命名规约：
A) Service/DAO 层方法命名规约
1） 获取单个对象的方法用 get 做前缀。
2） 获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。
3） 获取统计值的方法用 count 做前缀。
4） 插入的方法用 save/insert 做前缀。
5） 删除的方法用 remove/delete 做前缀。
6） 修改的方法用 update 做前缀。
B) 领域模型命名规约
1） 数据对象：xxxDO，xxx 即为数据表名。
2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。
3） 展示对象：xxxVO，xxx 一般为网页名称。
4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。

2.【强制】在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数
字 1 混淆，造成误解。
说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2。

3.【推荐】不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。
说明：大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解和维护。
正例：缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下。

8.【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：
1）第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。
2）运算符与下文一起换行。
3）方法调用的点符号与下文一起换行。
4）方法调用中的多个参数需要换行时，在逗号后进行。
5）在括号前不要换行，见反例。

7.【强制】所有整型包装类对象之间值的比较，全部使用 equals 方法比较。
说明：对于 Integer var = ? 在-128 至 127 范围内的赋值，Integer 对象是在 IntegerCache.cache 产
生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数
据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。

8.【强制】浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用
equals 来判断。
说明：浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进
Java 开发手册
 8/44
制无法精确表示大部分的十进制小数，具体原理参考《码出高效》。
反例：
 float a = 1.0f - 0.9f;
 float b = 0.9f - 0.8f;
 if (a == b) {
 // 预期进入此代码快，执行其它业务逻辑
 // 但事实上 a==b 的结果为 false
 }
 Float x = Float.valueOf(a);
 Float y = Float.valueOf(b);
 if (x.equals(y)) {
 // 预期进入此代码快，执行其它业务逻辑
 // 但事实上 equals 的结果为 false
 } 
正例：
(1) 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。
 float a = 1.0f - 0.9f;
 float b = 0.9f - 0.8f;
 float diff = 1e-6f;
 if (Math.abs(a - b) < diff) {
 System.out.println("true");
 }
(2) 使用 BigDecimal 来定义值，再进行浮点数的运算操作。
 BigDecimal a = new BigDecimal("1.0");
 BigDecimal b = new BigDecimal("0.9");
 BigDecimal c = new BigDecimal("0.8");
 BigDecimal x = a.subtract(b);
 BigDecimal y = b.subtract(c);
 if (x.equals(y)) {
 System.out.println("true");
 }
 
9. 【强制】定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。
正例：数据库字段的 bigint 必须与类属性的 Long 类型相对应。
反例：某个案例的数据库表 id 字段定义类型 bigint unsigned，实际类对象属性为 Integer，随着 id 越来
越大，超过 Integer 的表示范围而溢出成为负数。

10.【强制】为了防止精度损失，禁止使用构造方法 BigDecimal(double)的方式把 double 值转
化为 BigDecimal 对象。
说明：BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。
如：BigDecimal g = new BigDecimal(0.1f); 实际的存储值为：0.10000000149
正例：优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了
Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。
 BigDecimal recommend1 = new BigDecimal("0.1");
 BigDecimal recommend2 = BigDecimal.valueOf(0.1);
 
11.关于基本数据类型与包装数据类型的使用标准如下：
1） 【强制】所有的 POJO 类属性必须使用包装数据类型。
2） 【强制】RPC 方法的返回值和参数必须使用包装数据类型。
3） 【推荐】所有的局部变量使用基本数据类型。
说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或
者入库检查，都由使用者来保证。
正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。
反例：比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，
返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能
够表示额外的信息，如：远程调用失败，异常退出。

15.【强制】POJO 类必须写 toString 方法。使用 IDE 中的工具：source> generate toString
时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。
说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。

6.【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一
致、长度为 0 的空数组。
反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出
现 ClassCastException 错误。
正例：
List<String> list = new ArrayList<>(2);
list.add("guan");
list.add("bao");
String[] array = list.toArray(new String[0]);
 说明：使用 toArray 带参方法，数组空间大小的 length：
1） 等于 0，动态创建与 size 相同的数组，性能最好。
2） 大于 0 但小于 size，重新创建大小等于 size 的数组，增加 GC 负担。
Java 开发手册
 12/44
3） 等于 size，在高并发情况下，数组创建完成之后，size 正在变大的情况下，负面影响与上相同。
4） 大于 size，空间浪费，且在 size 处插入 null 值，存在 NPE 隐患。

9.【强制】泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用 add 方
法，而<? super T>不能使用 get 方法，作为接口调用赋值时易出错。
说明：扩展说一下 PECS(Producer Extends Consumer Super)原则：第一、频繁往外读取内容的，适合
用<? extends T>。第二、经常往里插入的，适合用<? super T>

13.【推荐】集合泛型定义时，在 JDK7 及以上，使用 diamond 语法或全省略。
说明：菱形泛型，即 diamond，直接使用<>来指代前边已经指定的类型。
正例：
// diamond 方式，即<>
HashMap<String, String> userCache = new HashMap<>(16);
// 全省略方式
ArrayList<User> users = new ArrayList(10);

14.【推荐】集合初始化时，指定集合初始值大小。
说明：HashMap 使用 HashMap(int initialCapacity) 初始化。
15.【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。
说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应
的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，
使用 Map.forEach 方法。

4.【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这
样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
说明：Executors 返回的线程池对象的弊端如下：
1） FixedThreadPool 和 SingleThreadPool：
允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。
2） CachedThreadPool：
允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。

11.【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存
加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。
说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于
3 次。

13.【推荐】资金相关的金融敏感信息，使用悲观锁策略。

19.【参考】ThreadLocal 对象使用 static 修饰，ThreadLocal 无法解决共享对象的更新问题。
说明：这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变
量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义
的)都可以操控这个变量。

1.【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。
说明：不要在方法体内定义：Pattern pattern = Pattern.compile(“规则”);

1.【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架
SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。

1.【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned 
tinyint（1 表示是，0 表示否）。

说明：任何字段如果为非负数，必须是 unsigned。
注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在<resultMap>设置从 is_xxx
到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取
值含义与取值范围。

3.【强制】表名不使用复数名词。
说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合
表达习惯。

14.【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。
说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。

1.【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。
说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，
即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。

2.【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询
时，保证被关联的字段需要有索引。
说明：即使双表 join 也要注意表索引、SQL 性能。

4.【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。
说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。

1.【强制】不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)是 SQL92 定义的
标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。
说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。

3.【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果
为 NULL，因此使用 sum()时需注意 NPE 问题。
正例：使用如下方式来避免 sum 的 NPE 问题：SELECT IFNULL(SUM(column), 0) FROM table;

6.【强制】不得使用外键与级联，一切外键概念必须在应用层解决。
说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外
键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级
联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风
险；外键影响数据库的插入速度。

9.【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控
制在 1000 个之内。

1.【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。


3.【参考】分层领域模型规约：
• DO（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。
• DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。
• BO（Business Object）：业务对象，由 Service 层输出的封装业务逻辑的对象。
• AO（Application Object）：应用对象，在 Web 层与 Service 层之间抽象的复用对象模型，极为贴
近展示层，复用度不高。
• VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。
• Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类
来传输。

2.【强制】二方库版本号命名方式：主版本号.次版本号.修订号
1）主版本号：产品方向改变，或者大规模 API 不兼容，或者架构不兼容升级。
2） 次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的 API 不兼容修改。
3） 修订号：保持完全兼容性，修复 BUG、新增次要功能特性等。
说明：注意起始版本号必须为：1.0.0，而不是 0.0.1，正式发布的类库必须先去中央仓库进行查证，使版
本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或
1.4.0 或 2.0.0


1.【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。
说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服务器端会因为
处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。
正例：在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）：
net.ipv4.tcp_fin_timeout = 30

3.【推荐】给 JVM 环境参数设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到
OOM 场景时输出 dump 信息。
说明：OOM 的发生是有概率的，甚至相隔数月才出现一例，出错时的堆内信息对解决问题非常有帮助。

4.【推荐】在线上生产环境，JVM 的 Xms 和 Xmx 设置一样大小的内存容量，避免在 GC 后调整
堆大小带来的压力。

8.【推荐】类在设计与实现时要符合单一原则。
说明：单一原则最易理解却是最难实现的一条规则，随着系统演进，很多时候，忘记了类设计的初衷。

### 第1章 计算机基础
网络协议
程序发送消息时，应用层按既定的协议打包数据，随后由传输层加上双方端口号，由网络层加上双方的IP地址，由链路层加上双方的MAC地址，
并将数据拆分数据帧，经过多个路由器和网关后，到达目标机器。简而言之，就是按“端口--IP地址--MAC地址”这样的路径进行数据的封装和发送，解包的时候反过来操作。
1.应用层
2.传输层
数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，
确认身份后，将数据包交给应用程序，实现端口到端口间通信。典型的传输协议是UDP和TCP。
3.网络层
4.链路层

IP协议
IP地址属于网络层，主要功能在WLAN内进行路由寻址，选择最佳路由。

TCP 连接的建立是通过文件描述待（ File Descriptor, fd） 完成的。
fd的数量将决定服务端进程所能建立连接的数量，对于大规模分布式服务来说，当fd不足时就会出现 open too many
files 错误而使得无法建立更多的连接。

查看当前系统各进程产生多少句柄
lsof -n | awk '{print $2}' | sort|uniq -c | sort -nr|more

ps -ax | grep 32764

三次握手

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。
服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，
服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，
服务器就认为客户端出了故障，接着就关闭连接。
三次握手目的：信息对等和防止超时
信息对等是指双方明确：自己发报能力、自己收报能力、对方发报能力、对方收报能力。
防止超时：由于TTL网络报文的生存时间往往超过TCP请求超时时间，如果两次握手就创建连接，传输数据并释放连接后，第一个超时的连接
请求才到达B机器，B机器以为是A创建新连接的请求，然后确认同意创建连接。

四次摆手

四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，
有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。
在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。
所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。
Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。
所谓的2MSL是两倍的MSL(Maximum  Segment  Lifetime)。MSL指一个片段在网络中最大的存活时间，
2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，
那么Client推断ACK已经被成功接收，则结束TCP连接。


连接池

合理拆分多个表 join SQL 是超过三个表则禁止 join 如果表结构建
得不合理，应用逻辑处理不当，业务模型抽象有问题 那么三表 join 的数据量由于笛
卡儿积操作会呈几何级数增加，所以不推荐这样的做法。

### 第2章 面向对象

####三大原则：封装、继承、多态

1. 封装

2. 继承  
2.1 继承问题
继承存在方法污染和方法爆炸,方法污染是指子类并不具备的行为能力，却继承父类的行为;  
方法爆炸，指继承树不断扩大，底层类拥有的方法虽然都能够执行，但由于方法众多，其中部分方法并非  
与当前类的功能定位相关，很容易在实际编程中产生选择困难。

3. 多态
多态是抽象、封装、继承三个面向对象的特性为基础，根据运行时的实际对象类型，同一个方法产生不同的运行结果，  
使用同一个行为具有不同的表现形式。  
“override”、“overload”,前者是覆写,继承后实现相同父的方法，是垂直方向上行为的不同实现;后者是重载，方法名相同，  
但是参数类型和参数个数是不相同的，是水平方向上行为的不同实现。  
多态是指在编译层面无法确定最终调用的方法体，以覆写为基础来实现面向对象性，在运行期由JVM进行动态绑定调用合适的覆写  
方法体来执行。重载是编译期确定方法调用，属于静态绑定。
  * 继承的存在（继承是多态的基础，没有继承就没有多态）
  * 子类重写父类的方法（多态下调用子类重写的方法）
  * 父类的引用变量指向子类的对象（子类到父类的类型转换）

####设计模式
#### 1. 迪米特法则
设计模式七大原则之一的迪米特法则就是对于封装的具体要求，即A模块使用B模块的某个接口行为，对B模块中除此行为之外的其他信息知道得尽可能少。
一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。

#### 2. 里氏代换原则
里氏代换原则（ Liskov Substitution Principle, LSP ）,LSP是指任何父类能够出现的地方，子类都能够出现。如，放下武器是父类，
放下手枪、放下匕首是子类。is-a关系需要符合里氏代换原则。

#### 3. 接口隔离原则
can-do要符合接口隔离原则，实现类要有能力去实现并执行接口中定义的行为。
如Plane can fly.Bird can fly.中应该把fly定义成一个接口，  
而不是把fly()放在某个抽象类中，再由Plane和Bird利用is-a  
关系去继承此抽象类。因此严格意义上讲，Plane和Bird除了fly这个行为外，在无其他共同特征。

#### 4.PECS（Producer Extends Consumer Super）原则
频繁往外读取内容的，适合用上界Extends，经常往里插入的，适合用下界Super


#### 5. 单一职责
指一个类的功能要单一，不能包罗万象，如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却不高。

#### 6. 开闭原则（Open-Close Principle）  
一个模块在扩展性方面应该是开放的，而在更改性能方面应该是封闭的。如：一个网络模块，原来只服务端功能，而现在要加入客户端
功能，那么应当在不用修改服务端功能代码前提下，就能够增加客户端功能的实现。

#### 7. 依赖倒置原则（the Dependency Inversion Principle DIP）  
具体依赖抽象，上层依赖下层，假设B是较A低的模块，但B需要使用A的功能，B不应该直接使用A中的具体类，而应当由
B定义一抽象接口。

#### JDK

#### JRE
包括JVM、核心类库、核心配置工具

#### JVM
java虚拟机

#### 类
类的定义由访问级别、类型、类名、是否抽象、是否静态、泛型标识、继承或实现关键字、父类或接口名称组成。  
类的访问级别有public和无访问控制等，类型分为class、interface、enum。

######表 接口与抽象类区别    

|    语法    |    抽象类    |        接口       |  
|:-----------|:-----------|:---------------|
|定义关键字|abstract|interface|
|子类继承或实现关键字|extends|implement|
|方法实现|可以有|不能有，但在JDK8及之后，允许有default实现|
|方法访问控制符|无限制|有限制，默认是public abstract类型|
|属性访问控制符|无限制|有限制，默认是public static final类型|
|静态方法|可以有|不能有|
|static{}静态代码块|可以有|不能有|
|本类型之间扩展|单继承|多继承|
|本类型之间扩展关键字|extends|extends|

抽象类在被继承时体现的是is-a关系，接口在被实现时体现的是can-do关系。抽象类是模板式设计，  
而接口是契约式设计。

###### 访问权限
|    访问权限控制符    |    任何地方    |        包外子类       |   包类  |  类内  |
|:-----------|:-----------:|:---------------:|:---------------:|:---------------:|
|public|是|是|是|是|
|protected|否|是|是|是|
|无|否|否|是|是|
|private|否|否|否|是|

public 可以修饰外部类、方法、属性，可以跨包、跨类、访问
protected 可以修饰方法、属性，表示受保护的、有限制的，可以被包内和包外子类访问
无 即无任何访问权限控制符，如示例中的 noneMethod 方法，没有任何
  修饰符。千万不要说成 default 它并非访问权限控制符的关键字 ，另外，在
  JDK8 接口中引入 default 默认方法实现 更加容易混淆两者释义。无访问权
  限控制符仅对包内可见。虽然无访问权限控制符还可以修饰外部类，但是定
  义外部类极少使用无控制符的方式，要么定义为内部类，功能内聚，要么定
  义公开类，即 public class ，包外也可以实例化。
  
 private 可以定义内部类、方法、属性，表示只能内类访问。
 
 访问控制从严处理：  
 
 (1）如果不允许外部直接通过 new 创建对象 构造方法必须是private  
 (2）工具类不允许有public和default 构造方法。  
 (3）类非 static 成员变量并且与子类共享 必须是 protected  
 (4）类非 static 成员变量并且仅在本类使用 必须是 private  
 (5）类 static 成员变量如果仅在本类使用 必须是 private  
 (6）若是 static 成员变量 必须考虑是否为 final  
 (7）类成员方法只供类内部调用 必须是 private  
 (8）类成员方法只对继承类公开 那么限制为 protected  
 
 #### 类关系
【继承】 extends (is-a)  
【实现】 implements (can do)  
【组合】 类是成员变量 (contains-a)  
【聚合】 类是成员变量（has-a)  
【依赖】 import类 (use-a)  

在类图中，用空心的三角形表示继承，用实心的菱形表示组合，用空心的菱形表
示聚合 这三者都是用实线连接的。用三角形来表示实现，用一个箭头表示依赖，
与前面的区别是这两者都是用虚线连接的。

#### 序列化
自定义serialVersionUID值的原因，是由于如果不设置，在每次运行时，编译器会  
根据类的内部实现，包括内名称、方法、属性等来自动生成。如果类的源代码有修改，
重新编译后serialVersionUID会发生变化，导致以前的序列化不能反序列化成功。


#### 构造方法
在接口中不能定义构造方法，在抽象类中可以定义。在枚举类中，构造方法是特
殊的存在 它可以定义，但不能加public 修饰 因为它默认是 private 的，是绝对的单例，
不允许外部以创建对象的方式生成枚举对象。

单一职责 对于构造方法同样适用 ，构造方法的使命就是在构造对象时进行传参
操作，所以不应该在构造方法中引入业务逻辑。

静态代码块，先执行父类，再执行本类，构造函数先执行父类，再执行本类。静态代码块只执行一次，第二次运行时不执行。


#### 类方法
分为构造方法、实例方法、静态方法、静态代码块
通常静态方法用于定义工具类的方法等，静态方法如果使用了可修改的对象，那
么在并发时会存在线程安全问题。所以，工具类的静态方法与单例通常是相伴而生的。
最典型的 getter setter 方法使用是在 POJO ( Plain Ordinary Java Object 简单的
Ja 对象）类中。在本书中 POJO 专指只包含 getter/ setter toString 方法的简单类
常见的 POJO 类包括 DO(Domain Object) BO (Business Object) DTO(Data Transfer 
Object) VO (View Object）、 AO(Application Object) POJO 作为数据载休，通常用于
数据传输，不应该包含任何业务逻辑。因此，在 POJO 类中， getter setter 不但是重
要的组成部分 更是与外界进行信息交换的桥梁。


#### 覆写
想成功地覆写父类方法，需要满足以下 个条件:
* 访问权限不能变小，相同或者变大  
* 返回类型能够向上转型成为父类的返回类型
向上转型是严格的继承关系
* 异常也要能向上转型成父类的异常
* 方法名、参数类型及个数必须严格一致

综上所述，方法的覆写可以总结成容易记忆的口诀 大两小两同”。
* 一大 子类的方法访问权限控制符只能相同或变大。
* 两小，抛出异常和返回值只能变小 能够转型成父类对象。子类的返回值、
抛出异常类型必须与父类的返回值、抛出异常类型存在继承关系。
* 两同 方法名和参数必须完全相同。

#### 重载
在编译器的眼里，方法名称＋参数类型＋参数个数，组成一个唯一键，称为方法签名， JVM通过这个
唯一键决定调用哪种重载的方法。

#### 泛型

#### 数据类型
基本类型，Java 种基本数据类型包括 boolean、byte、char、short、long、float、double、refvar。
包装类，Boolean、Byte、Character、Short、Integer、Long、Float、Double

在选择使用包装类还是基本数据类型时，推荐使用如下方式
* 所有的POJO类属性必须使用包装数据类型。
* RPC方法的返回值和参数必须使用包装数据类型。
* 所有的局部量推荐使用基本数据类型。

#### 字符串
字符串相关类型主要有三种：String、StringBuilder、StringBuffer。String是只读字符串，典型的immutable对象，对它的任何改动，其实都是
创建一个新的对象，再把引用指向该对象。StringBuffer可以在原对象上进行修改，是线程安全的。StringBuilder是非线程安全的。

### 第3章 代码风格

#### 命名规约
代码元素包括类、方法、变量、常量、参数等要素

##### 命名
在命名时若能体现出元素的特征，则有助于快速识别命名对象的作用，有助于快
速理解程序逻辑。我们推荐在 Java 命名时，以下列方式体现元素特征·
* 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名
统一使用单数形式，但是类名如果有复数含义，则可以使用复数形式。
* 抽象类命名使用 Abstract或Base 开头，异常类命名使用 Exception 结尾;
测试类命名以它要测试的类名开始，以 Test 结尾。
* 类型与中括号紧挨相连来定义数组。
* 枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下画线隔开。

换行时遵循如下原则:
* 第二行相对第一行 缩进4个空格，从第三行开始，不再继续缩进。
* 运算符与下文一起换行。
* 方法调用的点符号与下文一起换行。
* 方法调用中的多个参数需要换行时，在逗号后换行。
* 在括号前不要换行。

### 第4章 走近JVM
JVM在字节码上设计了一套操作码助记符，使用特殊单词来标记这些数字。字节码主要指令如下：
1. 加载或存储指令  
在某个栈帧中，通过指令操作数据在虚拟机栈的局部变量表与操作栈之间来回传输，常见指令如下：
   * 将局部变量加载到操作栈中。如ILOAD（将int类型的局部变量压入栈）和ALOAD（将对象引用的局部变量压入栈）
   * 从操作栈顶存储到局部变量表。如ISTORE、ASTORE等。
   * 将常量加载到操作栈顶，这是极为高频使用的指令。如ICONST、BIPUSH、SIPUSH、LDC等。
     * ICONST加载的是-1~5的数（ICONST和BIPUSH的加载界限）。
     * BIPUSH，即Byte Immediate PUSH，加载-128~127之间的数。
     * SIPUSH，即Short Immediate PUSH，加载-32768~32767之间的数。
     * LDC，即Load Constant，在-2147483648~2147483647或者是字符串时，JVM采用LDC指令压入栈中。
2. 运算指令  
对两个操作栈帧上的值进行运算，并把结果写入操作栈顶，如IADD、IMUL等。
3. 类型转换指令  
显示转换两种不同的数值类型，如I2L、D2F等。
4. 对象创建与访问指令  
根据类型进行对象的创建、初始化、方法调用相关指令，常见指令如下：
   * 创建对象指令。如NEW、NEWARRAY等。
   * 访问属性指令。如GETFIELD、PUTFIELD、GETSTATIC等。
   * 检查实例类型指令。如INSTANCEOF、CHECKCAST等。
5. 操作栈管理指令  
JVM提供了直接控制操作栈的指令，常见指令如下：
   * 出栈操作。如POP即一个元素，POP2即两个元素。
   * 复制栈顶元素并压入栈。如DUP。
6. 方法调用与返回指令  
常见指令如下：
   * INVOKEVIRTUAL指令：调用对象实例方法。
   * INVOKESPECIAL指令：调用实例初始化方法、私有方法、父类方法等。
   * INVOKESTATIC指令：调用类静态方法。
   * RETURN指令：返回VOID类型。
7. 同步指令  
JVM使用方法结构中的ACC_SYNCHRONIZED标志同步方法，指令集中有MONITORENTER和MONITOREXIT
支持synchronized语义。
8. 其它  
除字节码指令外，还包含一些额外信息。例如，LINENUMBER存储了字节码与源码行号的对应光敏，方便
调试的时候正确地定位到代码的所在行;LOCALVARIABLE存储当前方法中使用到的局部变量表。

#### 字节码编译过程
#------------------
JAVA源文件——词法解析-token流-语法解析——语义分析——生成字节码——字节码
   * 词法解析  
#------------------
词法解析是通过空格分隔出单词、操作符、控制符等信息，将其形成token信息流，传递给语法
解析器
   * 语法解析   
把词法解析得到的token信息流按照Java语法规则组装成一棵语法树。
   * 语义分析  
需要检查关键字的使用是否合理、类型是不叫匹配、作用域是否正确等。
   * 字节码  
当语义分析完成之后，即可生成字节码。字节码必须通过类加载过程加载到JVM环境后，才可以执行。
执行有三种模式：第一，解释执行；第二，JIT编译执行；第三，JIT编译与解释混合执行（主流JVM默认执行模式）。
混合模式执行的优势在于解释器在启动时先解释执行，省去编译时间。

#### 类加载过程
在冯*诺依曼定义的计算机模型中，任何程序都需要加载到内存才能与CPU进行交流。
字节码.class文件需要加载到内存中，才可以实例化类。ClassLoader提前加载.class类文件到内存中。
在加载类时，使用的是Parent Delegation Model，即双亲委派模型，意译“溯源委派加载模型”更贴切。
Java的类加载器是一个运行时核心基础设施模块，主要在启动之初进行类的Load、Link、Init，即
加载、链接、初始化。
   * Load  
   读取类文件产生二进制流，并转化为特定的数据结构，初步校验cafe babe魔法数、常量池、文件长度、
   是否有父类等，然后创建对应类的java.lang.Class实例。
   * Link  
   包括验证、准备、解析三个步骤
   * Init  
   执行类构造器<clinit>方法，如果赋值运算是通过其他类的静态方法来完成，那么会马上解析另外一个类，
   在虚拟机栈中执行完毕后通过返回值进行赋值。
   --XX:+TraceClassLoading参数，此参数在解决冲突时非常实用。

#### 内存布局
内存是非常重要的系统资源，是硬盘和CUP的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。
JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。
>>>>经典的JVM内存布局图
   * Heap（堆区）  
    Heap是OOM故障最主要的发源地，存储着几乎所有的实例对象，堆由垃圾收集器自动回收，堆区由各子线
程共享使用。通常，堆区占用的空间是所有内存区域中最大的。堆内存空间既可以固定大小，
也可以在运行时动态的调整，通过如下参数设定初始值和最大值，如-Xms256M -Xmx1024M，
其中-X表示它是JVM运行参数，ms是memory start，mx是memory max的简称，分别代表最小堆容量和
最大堆容量。在服务器运行过程中，堆空间不断地扩容与回缩，会造成系统压力，在线上生产环境中，JVM
的Xms和Xmx设置成一样大小，避免在GC后调整堆大小时带来额外的压力。
    堆分区新生代和老年代。对象产生之初在新生代，步入暮年时进入老年代，老年代也接纳在新生代无法
容纳的超大对象。
    新生代包括一个Eden和2个Survivor区，绝大部分对象在Eden区生成，当Eden区装填满时，会触发
Young Garbage Collecton，即YGC。垃圾回收时，在Eden区实现清除策略，没有被引用的对象直接回收。
依然存活的对象会被移送到Survivor区，

XX:MaxTenuringThreshold 当进行YGC时，在Survivor区交换的次数，如果为1从新生代的Eden区直接移
到老年代区，默认是15次，可以交换14次后，晋升至老年代。

Full Garbage Collection FGC，当在Eden区放不下的超大对象，老年代区也放不下时，进行FGC，之后还是
放不下时，OOM。

-XX:+HeapDumpOnOutOfMemoryError，让JVM遇到OOM异常时能输出堆内信息。

   * 元空间  
永久代Perm区，在JDK8版本中淘汰使用元空间替换永久代，JDK7及之前的版本中，只有Hotspot才有Perm区。
PermGenspace当Web工程中，功能点比较多，运行过程中，不断的加载很多的类，经常出现致命错误，如：
“Exception in thread ... java.lang.OutOfMemoryError:PermGenspace”
解决该问题，需要设定运行参数-XX: MaxPermSize=1280m。

JDK8中，以前Perm区中的所有内容中的字段串常量移至堆内存，其它内容包括类元信息、字段、静态属性、方法、
常量等移至元空间内。

   * JVM Stacks（虚拟机栈）
栈（Stack）是一个先进后出的数据结构。JVM中的虚拟机栈是描述Java方法执行的内存区域，它是线程私有的。
StackOverflowError表示请求的栈溢出，导致内存耗尽，通常出现在递归方法中。栈中的元素用于支持虚拟机进行
方法调用，每个方法从开始调用到执行完成的过程，就是栈帧入栈到出栈的过程。在活动线程中，只有位于栈顶的帧才是有效的，
称为当前栈帧。正在执行的方法称为当前方法，栈帧是方法运行的基本结构。
栈帧包括局部变量表、操作栈、动态连接、方法返回地址等。
     * 局部变量表
     是存放方法参数和局部变量的区域。
     * 操作栈
     是一个初始状态为空的桶式结构栈。
     * 动态连接
     每个栈帧中包含一个在常量池中对当前方法的引用，目的是支持方法调用过程的动态连接。
     * 方法返回地址
     方法执行时有两种退出情况：一是正常退出，即正常执行到任何方法的返回字节码指令，如RETURN、IRETURN、
     ARETURN;二是异常退出。无论何种退出情况，都将返回到方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧。
   * Native Method Stacks（本地方法栈）  
本地方法栈在JVM内存布局中，也是线程对象私有的，但是虚拟机栈“主内”，本地方法栈“主外”，内外是针对
JVM来说的，本地方法栈为Native方法服务。线程开始调用本地方法时，会进入一个不再受JVM约束的世界。
本地方法可以通过JNI（Java Native Interface）来访问虚拟机运行时的数据区，甚至可以调用寄存器。
当本地方法过多时，会消弱JVM对系统的控制力，因为它的出错信息比较黑盒。对不内存不足时，本地方法栈会抛出
native heap OutOfMemory。
本地方法最著名的是System.currentTimeMillis()，JNI使Java深度使用操作系统的特性功能，得胜非Java
代码。
   * Program Counter Register（程度计数寄存器）
程序计数器用来存放执行指令的偏移量和行号指示器等，线程执行和恢复都要依赖程序计数器。程序计数器
在各个线程之间互不影响，此区域也不会发生内存溢出异常。

从线程共享的角度来看，堆和元空间是所有线程共享的，而虚拟机栈、本地方法栈、程序计数器是线程内部私有的。

#### 对象实例化
Java是面向对象的静态强类型语言。
javap -verbose -p 查看对象创建的字节码

#### 垃圾回收
Java会对内存进行自动分配与回收管理，使上层业务更加安全，方便地使用内存实现程序逻辑。垃圾回收（Garbage Collection, GC）。
主要目的是清除不再使用的对象，自动释放内存。
为了判断对象是否存储，JVM引入了GC Roots。如果一个对象与GC Roots之间没有直接或间接的引用关系，如某个失去任何引用的对象，
或者两个互相环岛状循环引用的对象等，是可以被回收的。
类静态属性中引用的对象、常量引用的对象、虚拟机栈中引用的对象、本地方法栈中引用的对象可以
作为GC Roots
垃圾回收算法：
   * 标记-清除算法
   最基础的，会从每个GC Roots出发，依次标记有引用的关系的对象，最后将没有标记的对象清除。
   但是会带来大量的空间碎片，导致需要分配一个较大连续空间时容易触发FGC.
   * 标记-整理算法
   类似磁盘整理，先会从GC Roots出发标记存活的对象，然后将存活对象整理到内存空间的一端，
   形成连续的已使用空间，最后把已使用空间之外的部分全部清理掉。
   * Mark-Copy算法
   为了能够并行地标记和整理将空间分两块，每次只激活其中一块，垃圾回收时，只需要把存活的
   对象复制到另一块未激活空间上，将未激活空间标记为已激活，将已激活空间标为未激活，然后清除
   原空间中的原对象。Mark-Copy现作为主流的YGC算法进行新生代的垃圾回收。
   
垃圾回收器（Garbage Collector）是实现垃圾回收算法并应用在JVM环境中的内存管理模块。
当前实现的垃圾回收器有数十种，如Serial、CMS、G1三种。
   * Serial回收器
   主要应用于YGC的垃圾回收器，采用串行单线程的方式完成GC任务，其中“Stop The World”
   简称STW，即垃圾回收的某个阶段暂停整个应用程序的执行。
   * CMS回收器（Concurrent Mark Sweep Collector）
   是回收停顿时间比较短、目前比较常用的垃圾回收器。通过初始标记（Initial Mark）、
   并发标记（Concurrent Mark）、重新标记（Remark）、并发清除（Concurrent Sweep）
   四个步骤完成垃圾回收工作。第1和3步的初始标记和重新标记会引发STW，第2、4步的并发标记和
   并发清除两个阶段可以和应用程序并发执行，也是比较耗时的，但不影响程序正常执行。由于CMS
   采用标记-清除算法，会产生大量的空间碎片。可以配置置 -XX:+UseCMSCompactAtFullCollection
   参数，强制JVM在FGC完成后对老年代进行压缩，执行一次空间碎片整理，空间碎片整理会引发STW。
   * 新一代G1（Garbage-First Garbage Collector）垃圾回收
   Hotspot在JDK7中推出。通过-XX:+UseG1GC参数启用。和CMS相比，G1具备压缩功能，能避免
   碎片问题，暂停时间更加可控。
   
   
 ### 第5章 异常与日志
 处理异常需要解决三个问题：
    * 哪里发生异常？
    * 谁来处理异常？
    * 如何处理异常？
    
  #### 异常分类
  JDK中定义了一套完整的异常机制，所有异常都是Throwable的子类，分为Error类（致命异常）和Exception类（非致命异常）。
   * Error
   是一种非常特殊的异常类型，它的出现标识着系统发生了不可控的错误，例如StackOverFlowError、
   OutOfMemoryError。针对此类错误，程序无法处理，只能人工介入。
   * Exception  
   分为checked异常（受检异常）和unchecked异常（非受检异常）。  
     * checked异常
     需要在代码中显示处理的异常，否则会编译出错。
       * 无能为力、引起注意型，针对些类异常，程序无法处理，如字段超长等导致的SQLException，即使做再多的重试对解决异常也没有任何帮助。
       * 力所能及、坦然处理型，如发生未授权异常（UnAuthorizedException）,程序可跳转至权限申请页面。
     * unchecked异常
     运行时异常，它们都继承自RuntimeException，不需要程序进行显示的捕捉和处理。
       * 可预测异常（Predicted Exception），常见的异常包括NullpointerException、IndexOutOfBoundsException等。
       * 需捕捉异常（Caution Exception），如DubboTimeoutException，需要显示处理。
       * 可透出异常（Ignored Exception），框架或系统产生的且会自行处理的异常，而且程序无须关心。如针对Spring框架中抛出
       的NoSuchRequestHandlingMethodException异常，Spring框架会自己完成异常处理，默认将自身抛出的异常自动映射到合适的状态
       码，比如启动防护机制跳转到404页面。

#### 日志

* 注意问题  
记录异常时，一定要输出异常堆栈，例如logger.error("XXX" + e.getMessage(), e)。 

try 代码块与锁的关系， lock 方法可能会抛出 unchecked 异常，如果放
try 代码块中，必然触发 fi nally 中的 unlock 方法执行。对未加锁的对象解锁会抛
unchecked 异常，如 Illega!MonitorStateException 虽然是因为加锁失败而造成程
序中断的，但是真正加锁失败的原因可能会被后者覆盖。所以在町代码块之前调用
lock（） 方法，避免由于加锁失败导致 finally 调用 unlock（） 抛出异常。


### 第6章 数据结构与集合

#### 数据结构
数据组织形式，逻辑意义上的组织方式有很多，比如树、图、队列、哈希等。树可以是二叉树、
三叉树、B+树等；图可以是有向图和无向图；队列是先进先出的线性结构；哈希是根据某种算法
直接定位的数据组织方式。
数据处理方式，既定的数据组织方式上，以某种特定的算法实现数据的增加、删除、修改、查找
和遍历。
数据结构分为以下四类：
* 线性结构  
0至1个直接前继和直接后继。当线性结构非空时，有唯一的首元素和尾元素，除两者外，所有的元素
有唯一的直接前继和直接后继。线性结构包括顺序表、链接、栈、队列等，其中栈和队列是访问受限
结构，栈是先进后出LIFO，队列是先进先出，FIFO。
* 树结构  
0至1个直接前继和0到n个直接后继（n大于或等于2）。树是一种非常重要的有层次的非线性数据
结构。
* 图结构  
0至n个直接前继和直接后继（n大于或等2）。图结构包括简单图、多重图、有向图和无向图等。
* 哈希结构  
没有直接前继和直接后继。哈希结构通过某种特定的哈希函数将索引与存储的值关联起来，是一种查询
效率非常高的数据结构。  

数据结构的复杂度分为空间复杂度和时间复杂度两种，在存储越来越便宜，时间复杂度成为重点考量因素。
算法时间复杂度是一种衡量计算性能的指标，反映了程度执行时间随输入规模增长而增长的量级，在很大程度上
能够反映出算法性能的优劣与否。这个量级通常用大写的O和一个函数描述，如O(n^3)表示程序执行时间
随输入规模呈现3次方倍的增长，这是比较差的算法实现。从最好到最坏的常用算法复杂度排序如下：
常数级O(1)、对数级O(logn)、线性级O(n)、线性对数级O(nlogn)、平方级O(n^2)、立方级O(n^3)、
指数级O(2^n)等。

#### 集合
集合分为两类，第一类按照单个元素存储的Collection，Set和List都实现Collection接口；第二类按照
Key-Value存储的Map。
List、Queue、Set、Map的子类映射到数据结构中的表、树、哈希等。
* List集合  
线性数据结构的主要实现，集合元素通常存在明确的上一个和下一个元素，也存在明确的第一个元素和最后一个元素。
List集合遍历是稳定的，最常使用的是ArrayList和LinkedList两个集合类。
   * ArrayList  
   容量是可以改变的非线程安全集合。内部实现使用数组进行存储，集合扩容时会创建更大的数组空间，
   把原有数据复制到新数组中。支持快速随机访问，但是插入与删除时速度慢，由于要移动其它元素。
   默认容量是10，当再次分配时，按原容量的一半扩大，如果需要存储1000个元素，采用默认的构造方法，需要被动扩容13次
   才可以完成存储。如果初始化时便指定容量new ArrayList(1000)，可以避免被动扩容和数组的额外开销。
   * LinkedList  
   双向链表。与ArrayList相比，LinkedList插入和删除更快，但随机访问速度很慢。10万条数据，与
   ArrayList相比，随机提取元素时存在数百倍的差距。由于除继续AbstractList外，还实现了
   Deque接口，即double-ended queue。Deque具有栈和队列的性质。
   * CopyOnWriteArrayList  
   内部对Iterator进行加锁操作,是并发的一种新思路，实行读写分离，写操作时，复制一个新集合，在新集合内添加或删除元素，修改完后
   再将原集合的引用指向新的集合。由于是复制整个集合，当集合很大时，可能导致 GC。如果是大量的写入，导致速度慢，可以先写入arraylist，当COW的参数进行初始化。
   适合于读多写少的场景。COW是fail-safe机制的，是在安全副本上进行遍历，集合修改与遍历是没有关系的，导致读取的数据不是最新的，这
   也是CAP理论中C和A的矛盾，即一致性与可用性的矛盾。
   
* Queue集合  
是一种先进先出的数据结构，队列是一种特殊的线性表，只允许在表的一端进行获取操作，在表的另一端进行插入操作。
BlockingQueue(阻塞队列)，由于本身的FIFO和阻塞操作的特点，经常被作为Buffer(数据缓冲区)使用。

* Map集合  
以Key-Value键值对作为存储元素实现的哈希结构，Key按某种哈希函数计算后是唯一的，Value是可以重复的。Map
提供了三种Collection视图。使用KeySet()查看所有Key，使用values()查看所有值，使用entrySet查看所有的
键值对。最早用于存储键值对的Hashtable因为性能瓶颈已经被淘汰。HashMap是线程不安全的。ConcurrentHashMap是
线程安全的。TreeMap是Key有序的Map类集合。
   * HashMap  
   key和value可置入null。线程不安全
   HashMap有两个重要的参数：Capacity（决定容量大小）和Load Factor（加载因子，决定填充比例，默认是0.75，即是阀值容量占了3/4赶紧扩容减少Hash碰撞。），默认存储容量是16。
   JDK8，1.当存入数据大于阀值即发生扩容，2.存入数据到某一条链表时，此时链表数据个数大于8，且总数量小64发生扩容。进行了优化不用像JDK7那样重新计算hash值。
   扩容按旧容量和阀值的2倍计算新容量和阀值，扩容需要重建hash表，非常影响性能。
   hashcode为31的原因，31是一个奇质数，另外在二进制中，2个5次方是32,31 * i == (i << 5) - i。
   * TreeMap  
   key不可置入null，value可置入null。线程不安全，有序
   * ConcurrentHashMap  
   key和value不可为null。线程安全

* Set集合
Set是不允许出现重复元素的集合类型。最常用的是HashSet、TreeSet和LinkedHashSet。HashSet从源码分析是使用HashMap来实现的，
只是Value固定为一个静态对象，使用Key保证集合的唯一性，但不保证元素的顺序。TreeSet从源码分析是使用TreeMap来实现的，
底层为树结构，插入后集合仍然有序。LinkedHashSet继承自HashSet，内部使用链表维护了元素插入顺序。
   * HashSet
   * TreeSet
   * LinkedHashSet
####集合初始化  
进行分配容量、设置特定参数等相关工作。 

#### 数组与集合  

数组是一种顺序表，数组下标从0开始，是源于BCPL语言，它将指针设置在0的位置，用数组下标作为直接偏移量进行计算。如果从1开始，
云计算偏移量就要使用当前下标减1的操作，加减法对于CPU是一种双数运算，在数组下标使用频率极高的场景下，十分耗时。数组用于存储同一类
对象。Arrays是针对数组对象进行操作的工具类。Arrays.asList只能set，不能add/remove/clear，Arrays.asList体现的是适配器模式，
后台的数组仍是原有数组，set()方法即间接对数组进行值的修改操作。asList返回对象是一个Arrays的内部类，使用final修饰其中的元素数组。
数组转集合，应该使用List list = new ArrayList(Arrays.asList())。集合转数组，不要使用toArray()，丢失了泛型，
toArray(T[] array)  

#### 集合与泛型  

List<T>只能放一种类型，随意转换类型，“破窗理论”，泛型失去了类型安全的意义。
<? extends T> 写编译报错，可以读取，赋值为T本身或者子类，是Get First适用于消费集合元素为主的场景，<? super T>可以写入T本身或T的子类，
是Put First，适用于生产集合元素为主的场景，get操作类型丢失，即只能返回object对象，赋值为T本身或者T的父类。  


#### 元素的比较  

Comparable和Comparator，小于返回-1，等于返回0，大于返回1。  


#### hashCode equals  

两个方法协同来判断两个对象是否相等。对象通过调用Object.hashCode()生成哈希值，哈希冲突的情况不可避免，当hashCode相同时，还需要调用equals进行一
次值的比较。但是如果hashCode不同时，则两对象不相同，跳过equals，加快冲突处理效率。
Ojbect类定义对hashCode和equals要求如下：
* 如果两个对象equals结果相等，则两个对象的hashCode的返回结果也必须是相同的。
* 任何时候覆写equals，都必须同时覆写hashCode。  


#### fail-fast机制  

是集合世界中比较常见的错误检测机制，通常出现在遍历集合元素的过程中。它是一种集合遍历操作时的错误检测机制，在遍历
中途出现意料之外的修改时，通过unchecked异常暴力的反馈出来。多出现在多线程环境下。java.util下的集合类都是tail-fast，而
concurrent包中的集合类都是fail-safe  


#### Map类集合  

|   Map集合类   |   Key   |   Value   |   Super   |   JDK   |   说明   |  
|:---------:|:-------|:----------|:----------|:-------|:--------|  
|Hashtable|不允许为null|不允许为null|Dictonary|1.0|线程安全（过时）|  
|HashMap|允许null|允许null|AbstractMap|1.2|线程不安全|  
|TreeMap|不允许null|允许null|AbstractMap|1.2|线程不安全|  
|ConcurrentHashMap|不允许null|不允许null|AbstractMap|1.5|线程安全|  

#### 红黑树  
树是一种常用的数据结构，它是一个由有限节点组成的一个具有层次关系的集合，数据就存在树的这些节点中。最顶层只有一个节点，称为根节点。
在分支处有一个节点，指向多个方向，如果某节点下方没有任何分叉，就是叶子节点。从某节点出发，到叶子节点为止，最长简单路径上边的条数，
称为该节点的高度；从根节点出发，到某节点边的条数，称为该节点的深度。

   
