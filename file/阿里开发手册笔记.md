5. 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字
长。

6. 【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类
命名以它要测试的类的名称开始，以 Test 结尾。

8. 【强制】POJO 类中布尔类型变量都不要加 is 前缀，否则部分框架解析会引起序列化错误。
说明：在本文 MySQL 规约中的建表约定第一条，表达是与否的值采用 is_xxx 的命名方式，所以，需要在
<resultMap>设置从 is_xxx 到 xxx 的映射关系。
反例：定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()，RPC 框架在反向解
析的时候，“误以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。

9. 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使
用单数形式，但是类名如果有复数含义，类名可以使用复数形式。
正例：应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils（此规则参考 spring 的框架结构）

11.【强制】杜绝完全不规范的缩写，避免望文不知义。
反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重
降低了代码的可阅读性。

13.【推荐】在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。
正例：startTime / workQueue / nameList / TERMINATED_THREAD_COUNT
反例：startedAt / QueueOfWork / listName / COUNT_TERMINATED_THREAD

14.【推荐】如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。
说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。
Java 开发手册
 3/44
正例： public class OrderFactory;
 public class LoginProxy;
 public class ResourceObserver;
 
17.【参考】枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。
说明：枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有。
正例：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON。

18.【参考】各层命名规约：
A) Service/DAO 层方法命名规约
1） 获取单个对象的方法用 get 做前缀。
2） 获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。
3） 获取统计值的方法用 count 做前缀。
4） 插入的方法用 save/insert 做前缀。
5） 删除的方法用 remove/delete 做前缀。
6） 修改的方法用 update 做前缀。
B) 领域模型命名规约
1） 数据对象：xxxDO，xxx 即为数据表名。
2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。
3） 展示对象：xxxVO，xxx 一般为网页名称。
4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。

2. 【强制】在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数
字 1 混淆，造成误解。
说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2。

3. 【推荐】不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。
说明：大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解和维护。
正例：缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下。

8. 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：
1）第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。
2）运算符与下文一起换行。
3）方法调用的点符号与下文一起换行。
4）方法调用中的多个参数需要换行时，在逗号后进行。
5）在括号前不要换行，见反例。

7. 【强制】所有整型包装类对象之间值的比较，全部使用 equals 方法比较。
说明：对于 Integer var = ? 在-128 至 127 范围内的赋值，Integer 对象是在 IntegerCache.cache 产
生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数
据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。

8. 【强制】浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用
equals 来判断。
说明：浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进
Java 开发手册
 8/44
制无法精确表示大部分的十进制小数，具体原理参考《码出高效》。
反例：
 float a = 1.0f - 0.9f;
 float b = 0.9f - 0.8f;
 if (a == b) {
 // 预期进入此代码快，执行其它业务逻辑
 // 但事实上 a==b 的结果为 false
 }
 Float x = Float.valueOf(a);
 Float y = Float.valueOf(b);
 if (x.equals(y)) {
 // 预期进入此代码快，执行其它业务逻辑
 // 但事实上 equals 的结果为 false
 } 
正例：
(1) 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。
 float a = 1.0f - 0.9f;
 float b = 0.9f - 0.8f;
 float diff = 1e-6f;
 if (Math.abs(a - b) < diff) {
 System.out.println("true");
 }
(2) 使用 BigDecimal 来定义值，再进行浮点数的运算操作。
 BigDecimal a = new BigDecimal("1.0");
 BigDecimal b = new BigDecimal("0.9");
 BigDecimal c = new BigDecimal("0.8");
 BigDecimal x = a.subtract(b);
 BigDecimal y = b.subtract(c);
 if (x.equals(y)) {
 System.out.println("true");
 }
 
 9. 【强制】定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。
正例：数据库字段的 bigint 必须与类属性的 Long 类型相对应。
反例：某个案例的数据库表 id 字段定义类型 bigint unsigned，实际类对象属性为 Integer，随着 id 越来
越大，超过 Integer 的表示范围而溢出成为负数。

10.【强制】为了防止精度损失，禁止使用构造方法 BigDecimal(double)的方式把 double 值转
化为 BigDecimal 对象。
说明：BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。
如：BigDecimal g = new BigDecimal(0.1f); 实际的存储值为：0.10000000149
正例：优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了
Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。
 BigDecimal recommend1 = new BigDecimal("0.1");
 BigDecimal recommend2 = BigDecimal.valueOf(0.1);
 
11.关于基本数据类型与包装数据类型的使用标准如下：
1） 【强制】所有的 POJO 类属性必须使用包装数据类型。
2） 【强制】RPC 方法的返回值和参数必须使用包装数据类型。
3） 【推荐】所有的局部变量使用基本数据类型。
说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或
者入库检查，都由使用者来保证。
正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。
反例：比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，
返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能
够表示额外的信息，如：远程调用失败，异常退出。

15.【强制】POJO 类必须写 toString 方法。使用 IDE 中的工具：source> generate toString
时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。
说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。

6. 【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一
致、长度为 0 的空数组。
反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出
现 ClassCastException 错误。
正例：
List<String> list = new ArrayList<>(2);
list.add("guan");
list.add("bao");
String[] array = list.toArray(new String[0]);
 说明：使用 toArray 带参方法，数组空间大小的 length：
1） 等于 0，动态创建与 size 相同的数组，性能最好。
2） 大于 0 但小于 size，重新创建大小等于 size 的数组，增加 GC 负担。
Java 开发手册
 12/44
3） 等于 size，在高并发情况下，数组创建完成之后，size 正在变大的情况下，负面影响与上相同。
4） 大于 size，空间浪费，且在 size 处插入 null 值，存在 NPE 隐患。

9. 【强制】泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用 add 方
法，而<? super T>不能使用 get 方法，作为接口调用赋值时易出错。
说明：扩展说一下 PECS(Producer Extends Consumer Super)原则：第一、频繁往外读取内容的，适合
用<? extends T>。第二、经常往里插入的，适合用<? super T>

13.【推荐】集合泛型定义时，在 JDK7 及以上，使用 diamond 语法或全省略。
说明：菱形泛型，即 diamond，直接使用<>来指代前边已经指定的类型。
正例：
// diamond 方式，即<>
HashMap<String, String> userCache = new HashMap<>(16);
// 全省略方式
ArrayList<User> users = new ArrayList(10);

14.【推荐】集合初始化时，指定集合初始值大小。
说明：HashMap 使用 HashMap(int initialCapacity) 初始化。
15.【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。
说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应
的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，
使用 Map.forEach 方法。

4. 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这
样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
说明：Executors 返回的线程池对象的弊端如下：
1） FixedThreadPool 和 SingleThreadPool：
允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。
2） CachedThreadPool：
允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。

11.【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存
加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。
说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于
3 次。

13.【推荐】资金相关的金融敏感信息，使用悲观锁策略。

19.【参考】ThreadLocal 对象使用 static 修饰，ThreadLocal 无法解决共享对象的更新问题。
说明：这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变
量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义
的)都可以操控这个变量。

1. 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。
说明：不要在方法体内定义：Pattern pattern = Pattern.compile(“规则”);

1. 【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架
SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。

1. 【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned 
tinyint（1 表示是，0 表示否）。

说明：任何字段如果为非负数，必须是 unsigned。
注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在<resultMap>设置从 is_xxx
到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取
值含义与取值范围。

3. 【强制】表名不使用复数名词。
说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合
表达习惯。

14.【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。
说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。

1. 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。
说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，
即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。

2. 【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询
时，保证被关联的字段需要有索引。
说明：即使双表 join 也要注意表索引、SQL 性能。

4. 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。
说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。

1. 【强制】不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)是 SQL92 定义的
标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。
说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。

3. 【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果
为 NULL，因此使用 sum()时需注意 NPE 问题。
正例：使用如下方式来避免 sum 的 NPE 问题：SELECT IFNULL(SUM(column), 0) FROM table;

6. 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。
说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外
键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级
联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风
险；外键影响数据库的插入速度。

9. 【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控
制在 1000 个之内。

1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。


3. 【参考】分层领域模型规约：
• DO（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。
• DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。
• BO（Business Object）：业务对象，由 Service 层输出的封装业务逻辑的对象。
• AO（Application Object）：应用对象，在 Web 层与 Service 层之间抽象的复用对象模型，极为贴
近展示层，复用度不高。
• VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。
• Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类
来传输。

2. 【强制】二方库版本号命名方式：主版本号.次版本号.修订号
1）主版本号：产品方向改变，或者大规模 API 不兼容，或者架构不兼容升级。
2） 次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的 API 不兼容修改。
3） 修订号：保持完全兼容性，修复 BUG、新增次要功能特性等。
说明：注意起始版本号必须为：1.0.0，而不是 0.0.1，正式发布的类库必须先去中央仓库进行查证，使版
本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或
1.4.0 或 2.0.0


1. 【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。
说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服务器端会因为
处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。
正例：在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）：
net.ipv4.tcp_fin_timeout = 30

3. 【推荐】给 JVM 环境参数设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到
OOM 场景时输出 dump 信息。
说明：OOM 的发生是有概率的，甚至相隔数月才出现一例，出错时的堆内信息对解决问题非常有帮助。

4. 【推荐】在线上生产环境，JVM 的 Xms 和 Xmx 设置一样大小的内存容量，避免在 GC 后调整
堆大小带来的压力。

8. 【推荐】类在设计与实现时要符合单一原则。
说明：单一原则最易理解却是最难实现的一条规则，随着系统演进，很多时候，忘记了类设计的初衷。


网络协议
程序发送消息时，应用层按既定的协议打包数据，随后由传输层加上双方端口号，由网络层加上双方的IP地址，由链路层加上双方的MAC地址，
并将数据拆分数据帧，经过多个路由器和网关后，到达目标机器。简而言之，就是按“端口--IP地址--MAC地址”这样的路径进行数据的封装和发送，解包的时候反过来操作。
1.应用层
2.传输层
数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，
确认身份后，将数据包交给应用程序，实现端口到端口间通信。典型的传输协议是UDP和TCP。
3.网络层
4.链路层

IP协议
IP地址属于网络层，主要功能在WLAN内进行路由寻址，选择最佳路由。

TCP 连接的建立是通过文件描述待（ File Descriptor, fd） 完成的。
fd的数量将决定服务端进程所能建立连接的数量，对于大规模分布式服务来说，当fd不足时就会出现 open too many
files 错误而使得无法建立更多的连接。

查看当前系统各进程产生多少句柄
lsof -n | awk '{print $2}' | sort|uniq -c | sort -nr|more

ps -ax | grep 32764

三次握手

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。
服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，
服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，
服务器就认为客户端出了故障，接着就关闭连接。
三次握手目的：信息对等和防止超时
信息对等是指双方明确：自己发报能力、自己收报能力、对方发报能力、对方收报能力。
防止超时：由于TTL网络报文的生存时间往往超过TCP请求超时时间，如果两次握手就创建连接，传输数据并释放连接后，第一个超时的连接
请求才到达B机器，B机器以为是A创建新连接的请求，然后确认同意创建连接。

四次摆手

四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，
有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。
在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。
所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。
Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。
所谓的2MSL是两倍的MSL(Maximum  Segment  Lifetime)。MSL指一个片段在网络中最大的存活时间，
2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，
那么Client推断ACK已经被成功接收，则结束TCP连接。


连接池

合理拆分多个表 join SQL 是超过三个表则禁止 join 如果表结构建
得不合理，应用逻辑处理不当，业务模型抽象有问题 那么三表 join 的数据量由于笛
卡儿积操作会呈几何级数增加，所以不推荐这样的做法。

####三大原则：封装、继承、多态

1. 封装

2. 继承  
2.1 继承问题
继承存在方法污染和方法爆炸,方法污染是指子类并不具备的行为能力，却继承父类的行为;  
方法爆炸，指继承树不断扩大，底层类拥有的方法虽然都能够执行，但由于方法众多，其中部分方法并非  
与当前类的功能定位相关，很容易在实际编程中产生选择困难。

3. 多态
多态是抽象、封装、继承三个面向对象的特性为基础，根据运行时的实际对象类型，同一个方法产生不同的运行结果，  
使用同一个行为具有不同的表现形式。  
“override”、“overload”,前者是覆写,继承后实现相同父的方法，是垂直方向上行为的不同实现;后者是重载，方法名相同，  
但是参数类型和参数个数是不相同的，是水平方向上行为的不同实现。  
多态是指在编译层面无法确定最终调用的方法体，以覆写为基础来实现面向对象性，在运行期由JVM进行动态绑定调用合适的覆写  
方法体来执行。重载是编译期确定方法调用，属于静态绑定。

####设计模式
#### 1. 迪米特法则
设计模式七大原则之一的迪米特法则就是对于封装的具体要求，即A模块使用B模块的某个接口行为，对B模块中除此行为之外的其他信息知道得尽可能少。

#### 2. 里氏代换原则
里氏代换原则（ Liskov Substitution Principle, LSP ）,LSP是指任何父类能够出现的地方，子类都能够出现。如，放下武器是父类，
放下手枪、放下匕首是子类。is-a关系需要符合里氏代换原则。

#### 3. 接口隔离原则
can-do要符合接口隔离原则，实现类要有能力去实现并执行接口中定义的行为。
如Plane can fly.Bird can fly.中应该把fly定义成一个接口，  
而不是把fly()放在某个抽象类中，再由Plane和Bird利用is-a  
关系去继承此抽象类。因此严格意义上讲，Plane和Bird除了fly这个行为外，在无其他共同特征。


#### 4. 单一职责

#### JDK

#### JRE
包括JVM、核心类库、核心配置工具

#### JVM
java虚拟机

#### 类
类的定义由访问级别、类型、类名、是否抽象、是否静态、泛型标识、继承或实现关键字、父类或接口名称组成。  
类的访问级别有public和无访问控制等，类型分为class、interface、enum。

######表 接口与抽象类区别    

|    语法    |    抽象类    |        接口       |  
|:-----------|:-----------|:---------------|
|定义关键字|abstract|interface|
|子类继承或实现关键字|extends|implement|
|方法实现|可以有|不能有，但在JDK8及之后，允许有default实现|
|方法访问控制符|无限制|有限制，默认是public abstract类型|
|属性访问控制符|无限制|有限制，默认是public static final类型|
|静态方法|可以有|不能有|
|static{}静态代码块|可以有|不能有|
|本类型之间扩展|单继承|多继承|
|本类型之间扩展关键字|extends|extends|

抽象类在被继承时体现的是is-a关系，接口在被实现时体现的是can-do关系。抽象类是模板式设计，  
而接口是契约式设计。

###### 访问权限
|    访问权限控制符    |    任何地方    |        包外子类       |   包类  |  类内  |
|:-----------|:-----------:|:---------------:|:---------------:|:---------------:|
|public|是|是|是|是|
|protected|否|是|是|是|
|无|否|否|是|是|
|private|否|否|否|是|

public 可以修饰外部类、方法、属性，可以跨包、跨类、访问
protected 可以修饰方法、属性，表示受保护的、有限制的，可以被包内和包外子类访问
无 即无任何访问权限控制符，如示例中的 noneMethod 方法，没有任何
  修饰符。千万不要说成 default 它并非访问权限控制符的关键字 ，另外，在
  JDK8 接口中引入 default 默认方法实现 更加容易混淆两者释义。无访问权
  限控制符仅对包内可见。虽然无访问权限控制符还可以修饰外部类，但是定
  义外部类极少使用无控制符的方式，要么定义为内部类，功能内聚，要么定
  义公开类，即 public class ，包外也可以实例化。
  
 private 可以定义内部类、方法、属性，表示只能内类访问。
 
 访问控制从严处理：  
 
 (1）如果不允许外部直接通过 new 创建对象 构造方法必须是private  
 (2）工具类不允许有public和default 构造方法。  
 (3）类非 static 成员变量并且与子类共享 必须是 protected  
 (4）类非 static 成员变量并且仅在本类使用 必须是 private  
 (5）类 static 成员变量如果仅在本类使用 必须是 private  
 (6）若是 static 成员变量 必须考虑是否为 final  
 (7）类成员方法只供类内部调用 必须是 private  
 (8）类成员方法只对继承类公开 那么限制为 protected  
 
 #### 类关系
【继承】 extends (is-a)  
【实现】 implements (can do)  
【组合】 类是成员变量 (contains-a)  
【聚合】 类是成员变量（has-a)  
【依赖】 import类 (use-a)  

在类图中，用空心的三角形表示继承，用实心的菱形表示组合，用空心的菱形表
示聚合 这三者都是用实线连接的。用三角形来表示实现，用一个箭头表示依赖，
与前面的区别是这两者都是用虚线连接的。

#### 序列化
自定义serialVersionUID值的原因，是由于如果不设置，在每次运行时，编译器会  
根据类的内部实现，包括内名称、方法、属性等来自动生成。如果类的源代码有修改，
重新编译后serialVersionUID会发生变化，导致以前的序列化不能反序列化成功。


#### 构造方法
在接口中不能定义构造方法，在抽象类中可以定义。在枚举类中，构造方法是特
殊的存在 它可以定义，但不能加public 修饰 因为它默认是 private 的，是绝对的单例，
不允许外部以创建对象的方式生成枚举对象。

单一职责 对于构造方法同样适用 ，构造方法的使命就是在构造对象时进行传参
操作，所以不应该在构造方法中引入业务逻辑。

静态代码块，先执行父类，再执行本类，构造函数先执行父类，再执行本类。静态代码块只执行一次，第二次运行时不执行。


#### 类方法



